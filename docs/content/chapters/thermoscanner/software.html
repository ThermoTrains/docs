<h3>Software</h3>

<h4>Software Landschaft</h4>

<ul>
  <li>Thermobox</li>
  <li>Sentry</li>
  <li>Cockpit</li>
  <li>Thermoboard</li>
  <li>Github</li>
  <li>GitHub</li>
  <li>Teamviewer</li>
</ul>

<p>
  Um die vielfältigen Anforderung an die Entwicklung der Software abzudecken haben wir über den Verlauf dieser Arbeit
  eine ganze Software-Landschaft aufgebaut um unsere Hardware.
</p>

TODO Diagramm

<h4>Technologie</h4>

TODO diese Tabelle eventuell weiter oben als übersicht?

<figure>
  <table>
    <thead>
    <tr>
      <th>Repository</th>
      <th>Sprachen</th>
      <th>Frameworks</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>thermobox</code></td>
      <td>C#, Powershell, Batch</td>
      <td>.NET, FLIR Atlas, Basler Pylon, EMGU.CV, Raven, Log4Net</td>
    </tr>
    <tr>
      <td><code>thermoboard</code></td>
      <td>PHP, Typescript</td>
      <td>Laravel, Angular</td>
    </tr>
    <tr>
      <td><code>thermobox-cockpit</code></td>
      <td>PHP, HTML</td>
      <td>keine</td>
    </tr>
    <tr>
      <td><code>supersimplemonitoring</code></td>
      <td>PHP, HTML</td>
      <td>Chart.JS</td>
    </tr>
    <tr>
      <td><code>research</code></td>
      <td>Matlab</td>
      <td>keine</td>
    </tr>
    <tr>
      <td><code>post-processing</code></td>
      <td>Java</td>
      <td>OpenCV</td>
    </tr>
    </tbody>
  </table>
  <figcaption>Übersicht Code Repositories</figcaption>
</figure>

<h5>Continous Integration</h5>
<p>
  Zu einem guten Entwicklungsprozess gehört Continuous Integration. Da es für die zu verwendeten Technologien und
  Frameworks keine gratis Dienste gibt und wir selber keine Server besitzen die diese Aufgabe übernehmen könnten,
  haben wir die Thermobox selber als Continuous Integration Server eingesetzt. Startet die Thermobox wird automatisch
  der HEAD commit aus dem Git repository auf dem master Branch ausgecheckt. Dann werden die Nuget Dependencies
  aktualisiert. Somit kann anschliessend der Release Build durchgeführt werden. Alle Assemblies erhalten die korrekte
  Versionsnummer die im Repository in der Datei <code>SharedAssemblyInfo.cs</code> eingecheckt ist. Weil wir aber
  nicht andauernd die Version erhöhen möchten um diese bauen zu lassen, hängen wir auch den Commit Hash hinten daran.
  Dieser String kann mit folgendem Git Befehl erzeugt werden:
</p>

<figure>
  <pre><code>git describe --long --tags</code></pre>
  <figcaption>Version mit Git Commit Hash erzeugen Befehl</figcaption>
</figure>

<p>
  Dies erzeugt einen String wie diesen: <code>1.0.0-52-ge078b31</code>. Diese Versionsnummer ist deswegen wichtig
  weil wir in den Logs auf diese zurückgreifen. Dazu mehr im Kapitel <a href="#thermobox-logging">Logging</a>.
</p>

<h5>Unit Testing</h5>
<p>
  Um die verschiedenen Komponenten und insbesondere die Bildanalyse Algorithmen zu entwickeln haben wir wo es sind
  macht, TDD (Test Driven Development) eingesetzt. Seit Visual Studio 2017 Update 5 gibt es in der Enterprise Edition
  (welche wir über Microsoft Imagine via Schulaccount beziehen können) Live Unit Testing. Dieses nette Feature
  erkennt live welche Unit Tests von der Code Änderung betroffen sind und führt diese nach einem Build automatisch
  aus. Das Resultat wird gleich links leben den Zeilennummern im Editor angezeigt.
</p>

<figure>
  <img src="images/thermoscanner/screenshot-live-unit-testing.png">
  <figcaption>Screenshot Live Unit Testing</figcaption>
</figure>

<p>
  Zu beachten ist, dass Visual Studio dabei sämtliche Dateiänderungen folgt. In unserem Build wurde anfänglich
  jedesmal die Datei <code>SharedVersionInfo.cs</code> generiert welche die aktuelle Versionsnummer enthält. Dies hat
  den Build jedes mal neu getriggert. Somit hat Visual Studio non-Stopp gebuilded und die Unit Tests ausgeführt. Nach
  dem hilfreichen Feedback auf eine <a
  href="https://developercommunity.visualstudio.com/content/problem/152749/live-unit-testing-rebuilding-non-stop.html">Frage
  in der Visual Studio Developer Community</a> konnten wir aber auch diesen Issue beheben in dem wir den Build nur
  triggern wenn es die Datei noch nicht gibt. Zudem löschen wir diese zu Beginn eines Builds damit sie dann auch
  wirklich neu generiert wird.
</p>

<h5 id="thermobox-logging">Logging</h5>
<p>
  Um auch später nachvollziehen zu können was in der Software passiert, ist ein umfängliches Logging unumgänglich.
  Wir setzen dazu log4net ein. Die Konfiguration des Loggings ist für alle Konfigurationen die selbe und wird
  geteilt. Somit müssen kleine Anpassungen an der Konfiguration nicht über all nachvollzogen werden. Die Log Dateien
  werden pro Komponente in eine Datei im Pfad <code>C:\Thermobox\logs\</code> abgelegt. Eine Zeile im Log enthält
  folgende Informationen:
</p>

<ul>
  <li>Datum</li>
  <li>Uhrzeit auf die Millisekunde genau</li>
  <li>Assembly Name</li>
  <li>Version</li>
  <li>Git Commit Hash</li>
  <li>Log Level</li>
  <li>Nachricht</li>
</ul>

<p>
  Eine Log Zeile sind dann als Beispiel so aus:
</p>

<figure>
  <pre><code>2017-11-20 09:06:44,724 TemperatureReader.exe-1.0.0-1-gb652480
    [INFO] Received message on channel cmd:capture:start: 2017-11-20@09-06-44</code></pre>
  <figcaption>Beispiel Log Zeile</figcaption>
</figure>

<p>
  Wird eine Log Datei zu gross wird diese automatisch umbenannt und es wird eine neue Datei begonnen. Wir haben ein
  Threshold von 10 MiB gewählt. Dieser wurde eigentlich nur von der VisibleLightReader-Komponente erreicht weil wir
  dort Debug Logs um den Detektionsalgorithmus laufend zu verbessern. Gesamthaft haben wir über die zwei Testphasen
  ca. 154 MiB an Logdateien gesammelt.
</p>

<p>
  Auf einer Logzeile wird der Assembly Name aufgeführt. Dies mag redundant erscheinen weil dieser ja auch bereits in
  der Logdatei enthalten ist. Allerdings starten mit dem Start Script alle Komponenten miteinander und lassen diese
  auch auf die selbe Konsole schreiben damit man nicht 6 verschiedene Fenster offen und überwachen muss. Im
  Normalbetrieb starten die Komponenten im Hintergrund. Somit hätte man eigentlich keine Möglichkeit die Logs
  aggregiert zu sehen. Man kann höchstens ein <code>tail</code> auf die einzelnen Dateien machen. Also haben wir ein
  Powershell Script geschrieben, dass sämtliche Logdateien folgt. Zudem färbt es die verschiedenen Loglevels auch
  gleich ein. Also erscheint eine Exception auch gleich rot. Die Entwicklung des Scripts war nicht ganz einfach weil
  pro Logdatei ein Thread gestartet werden muss der einer einzelnen Logdatei folgt und dessen neuen Logs zurück auf
  die Hauptkonsole schreibt. Diese Lösung könnte eventuell auch für andere Projekte interessant sein.
</p>

<p>
  Um das Logging muss man sich bei einem Wiederbetrieb der Kabine als erstes nicht kümmern. Logs werden nur lokal
  abgelegt. Auch die Scripts zur aggregierten Ansicht der Logs gehen nehmen zusätzliche Komponenten Logs automatisch
  auf.
</p>

<h5>Remote Access</h5>
<p>
  Um von Fern auf den Mini-PC und die Hardware zu zugreifen, haben wir einen Teamviewer Server installiert. Dieser
  ermöglicht es mit einer Partner ID und einem Passwort darauf zuzugreifen. Teamviewer bietet das beste
  Benutzererlebnis verschiedenster Remote Access Lösungen. Auf die Standard Windows Remote Desktop Lösung können wir
  nicht zugreifen, weil der Server direkt mit einer IP im Internet angebunden ist welche nicht statisch ist.
  Teamviewer darf für nicht kommerzielle Zwecke gratis eingesetzt werden. Sobald die SBB das Projekt weiterführt,
  müsste ein Lizenz angeschafft werden sofern noch keine bestehen.
</p>

<h5>Hardware Monitoring</h5>
<p>
  Wir stellen unsere Hardware an einem Ort auf an dem es externe Einflüsse gibt die wir nicht unter Kontrolle haben.
  So kann z.B. jemand den Kasten ausstecken, Regen kann hineingelangen und einen Kurzschluss erzeugen oder er
  verliert die Netzwerkkonnektivität. Wir möchten also überwachen können ob die Thermobox läuft. Also brauchen wir
  ein Tool zur Überwachung der Uptime.
</p>

<p>
  Weiter möchten wir die Temperatur der Hardware überwachen um eventuelle Konstruktionsbedingte Wärmestaus frühzeitig
  zu erkennen bevor es anfängt zu schmelzen. Die Hardware ist draussen und kann nur in den vorgebenenen Temperaturen
  betrieben werden. Durch eine Fehlfunktion des Heizlüfters oder Thermostats könnte des Innere des Gehäuses auch
  überhitzt werden. Oder der Mini PC erzeugt eventuell so viel Hitze, dass diese nicht abgebaut werden kann. Einen
  Lüftungsschlitz nach aussen gibt es nämlich nicht. Die einzige undichte Ort ist der Kabelschlitz im Boden des
  Gehäuses. Also möchten wir die Temperatur des Mini-PCs überwachen können.
</p>

<p>
  Um Erkenntnisse über die Performance der Software Suite zu gelangen und eventuell zu erkennen, dass das System
  überlastet ist möchten wir auch die CPU Last sowie den Memory Verbrauch analysieren können. Die
  Performance-intensivsten Abläufe sind folgende:
</p>

<ul>
  <li>Bildanalyse ob ein Zug im Bild ist</li>
  <li>Aufnahme Full HD Farbvideo mit Live H.264 Kompression</li>
  <li>Aufnahme Infrarot Bilder</li>
  <li>Clamping Infrarot Bilder von 16 bits zu 8 bits</li>
  <li>Nachträgliche H.264 Kompression der Infrarot Bilder</li>
</ul>

<p>
  Diese Abläufe können sich auch in die Quere kommen was wir erkennen möchten. Zudem möchten wir erkennen wenn der
  Arbeitsspeicher ausgeht und eventuell auf die Disk geswapped wird.
</p>

<p>
  Um diese Daten aufzunehmen haben wir nach einer Monitoring Lösung gesucht. Dazu gibt es diverse Self-Hosting
  Lösungen wie z.B. das alt bekannte Nagios wovon es mittlerweile auch schon diverse Forks gibt. Diese Lösungen
  können wir allerdings nicht selber betreiben weil uns die Server dazu fehlen. Ausserdem ist ein solches System
  dafür ausgelegt eine ganze Serverlandschaft zu überwachen und nicht nur einen einzigen. Deswegen ist die
  Installation und Konfiguration einer solchen Lösung sehr aufwändig. Diesen Aufwand wollten wir uns wenn möglich
  sparen.
</p>

<p>
  Die andere Option ist eine SaaS Monitoring Lösung zu verwenden. Das Problem hierbei ist, dass es keine Anbieter
  gibt die das gratis machen. Oder jedenfalls nicht so, dass wir mehrere Monate lang auf den Server zugreifen können.
</p>

<p>
  Deswegen haben wir uns entschlossen eine eigene Lösung zu schaffen die wir auf dem Server von Sebastian Häni hosten
  können. Die entworfene Lösung ist so simpel gehalten wie möglich und ist nicht sehr erweiterbar. Die Funktionsweise
  ist so, dass die Thermobox alle 5 Minuten ein Datentupel im JSON Format mit folgenden Werten an den Server per HTTP
  POST schickt:
</p>

<ul>
  <li>CPU Temperaturen in Celsius pro Core</li>
  <li>CPU Auslastung in Prozent pro Core</li>
  <li>Memory Auslastung in Prozent</li>
  <li>Freier Festplattenspeicher in Bytes</li>
  <li>Hostname</li>
</ul>

<p>
  Der Server hängt das Datentupel an eine Datei. Das Frontend liest dann diese Datei aus und erzeugt eine HTML Seite
  die vier Graphen im Browser darstellt. Oben links wird dargestellt ob die Box online ist. Oben rechts werden die
  CPU Auslastung sowie die CPU Temperatur überlagert dargstellt. Unten links sieht man die Memory Auslastung. Und
  unten rechts sieht man den Verlauf des freien Speicherplatzes.
</p>

<figure>
  <img src="images/thermoscanner/monitoring-screenshot.jpg">
  <figcaption>Screenshot Monitoring</figcaption>
</figure>

<p>
  Der Source Code ist ausnahmsweise nicht im ThermoTrains Github Repository eingecheckt, weil diese Lösung nicht
  spezifisch für dieses Projekt funktionieren kann. Im Code ist nichts spezifisches was auf dieses Projekt hinweist.
  Das Repository kann unter <a href="https://github.com/sebastianhaeni/supersimplemonitoring">
  https://github.com/sebastianhaeni/supersimplemonitoring</a> gefunden werden.
</p>

<p>
  Weil es ab und zu vorkam, dass die Software nicht so funktionierte wie gewünscht, hat sich die Festplatte gefüllt
  und es konnten keine Aufnahmen mehr gemacht werden. Um sofort reagieren zu können wenn dies bald der Fall sein
  wird, schickt der Server eine E-Mail mit der Information, dass weniger als 5 GiB freier Speicherplatz zur Verfügung
  ist.
</p>

<figure>
  <img src="images/thermoscanner/screenshot-monitoring-email.png">
  <figcaption>Screenshot Monitoring E-Mail Benachrichtigung</figcaption>
</figure>

<p>
  Die Anforderungen an den Monitoring Server sind folgende:
</p>

<ul>
  <li>PHP 7+</li>
  <li>Schreibberechtigung auf <code>data/stats.txt</code></li>
</ul>

<p>
  Um den Server in Betrieb zu nehmen müssen nur die Sourcen auf den Webserver kopiert werden und die
  Schreibberechtigung eingerichtet werden. Im <code>ping.ps1</code> Script muss die richtige URL konfigurtiert werden
  damit die Datentupel an den richtigen Ort gelangen. Es gibt kein Mechanismus die alten Daten zu löschen. Dazu muss
  manuell die Datei <code>stats.txt</code> geleert werden. Die Graphen stellen jeweils nur die letzten 48 Stunden
  dar. Details über ältere Posts können mit dem Button "Show more" angezeigt werden.
</p>

<p>
  Der Client, also in unserem Fall der Thermo-Scanner, führt das Script <code>ping.ps1</code>, welches ebenfalls im
  Repository zu finden ist, alle 5 Minuten aus. Dieser allgemein als Cron-Job bekannte Prozess kann auf dem Mini-PC
  auf welchem Windows 10 läuft mit dem Task Scheduler gesteuert werden. Folgend zwei Screenshots wie der Task
  konfiguriert wurde:
</p>

<figure>
  <img src="images/thermoscanner/monitoring-task-configuration-1.png">
  <figcaption>Konfiguration Monitoring Ping Task Generell</figcaption>
</figure>

<figure>
  <img src="images/thermoscanner/monitoring-task-configuration-2.png">
  <figcaption>Konfiguration Monitoring Ping Task Trigger</figcaption>
</figure>

<p>
  Im Register Actions wurde eine Action hinzugefügt. Diese ist vom Typ "Start a program". Das Programm ist
  <code>powershell</code> und die Argumente sind
  <code>-NoLogo -File C:\repos\thermotrains\src\main\csharp\Scripts\ping.ps1 -WindowStyle Hidden"</code>.
</p>

<p>
  Das Ping Script <code>ping.ps1</code> ist in Powershell geschrieben. Es liest die CPU Temperaturen, CPU
  Auslastungen und die Memory Auslastung vom OpenHardwareMonitor aus. Um diese Angaben zuverlässig und einfach
  auslesen zu können gibt es von Windows leider keine vorgegebenen Befehler oder Services. Das Auslesen des
  verbleibenden Speicherplatzes ist jedoch mit Powershell Hausmitteln möglich.
</p>

<p>
  Eine generell funktionierende Lösung um die Sensoren der Hardware auszulesen gibt es nicht. Jeder Hersteller
  prorammiert in seinen Treibern eigene Interfaces um die Werte auszulesen. Die Software OpenHardwareMonitor versucht
  diese verschiedenen Interfaces zusammen zu tragen und stellt diese im einfachen Tool dar. Zusätzlich bietet
  OpenHardwareMonitor die Option an beim Systemstart sich selber im Tray auszuführen. Dies haben wir auf dem Mini-PC
  so konfiguriert. Wenn OpenHardwareMonitor läuft, kann über die angebotenen WMI Objekte (Windows Managment
  Instrumentation) auf die Sensor Werte mit simplen Queries zugegriffen werden. Als Beispiel hier ein Befehl welcher
  alle CPU Kern Temperaturen in Kelvin ausliest:
</p>

<figure>
  <pre><code>$temp = Get-WmiObject -Namespace "root/OpenHardwareMonitor" Sensor `
  | Where-Object {$_.SensorType -eq 'Temperature' -and $_.Name -like 'CPU Core #*'} `
  | Select-Object Value `
  | ForEach-Object {$_.Value}</code></pre>
  <figcaption>CPU Temperatur Auslesen Powershell Script</figcaption>
</figure>

<figure>
  <img src="images/thermoscanner/screenshot-openhardwaremonitor.png">
  <figcaption>Screenshot OpenHardwareMonitor</figcaption>
</figure>

<h5>Error Monitoring</h5>
<p>
  In den jeweiligen Komponenten können Errors und Warnungen geloggt oder gar uncatchted Exceptions auftreten. Um
  diese nicht mühsam im Log suchen zu müssen sollen diese einfacher eingesehen werden können. Zudem sollte bei neuen
  Fehler gleich eine E-Mail Benachrichtigung versendet werden.
</p>

<p>
  Dazu haben wir Sentry integriert. Sentry ist ein Dienst, welcher selber gehosted werden kann oder auf sentry.io
  betrieben wird. Da die Gratis-Lizenz mit ihren Einschränkungen für uns gut reicht, müssen wir keine Kosten
  aufwenden. Wenn eine Warnung oder Fehler auftritt, wird dieses Event an die Sentry API gemeldet. Sentry aggregiert
  dann die Events zusammen und schickt bei neuen unentdeckten Events eine E-Mail an uns.
</p>

<figure>
  <img src="images/thermoscanner/screenshot-sentry.png">
  <figcaption>Screenshot Sentry</figcaption>
</figure>

<p>
  Der Dienst ermöglicht es uns die Fehler sofort zu beheben nachdem sie aufgetreten sind. Zudem können wir die
  Warnungen dazu benutzen um zu sehen wie häufig und wann gewisse Meldungen auftauchen. Zum Beispiel schicken wir
  immer eine Warnung wenn ein Zug entdeckt wurde dieser aber "anscheinenden" nach zu kurzer Zeit schon wieder aus dem
  Bild gefahren ist, dass das eigentlich gar nicht möglich ist. Wenn wir dann sehen, dass das immer während der
  Dämmerung passiert ist das ein guter Hinweis was womöglich mit der Bildanalyse schief läuft.
</p>

<p>
  Um Sentry einzubinden mussten wir einen eigenen log4net Appender bauen. Die existierenden Appender sind zu alt und
  werden nicht mehr gewartet. Sollte sich in naher Zukunft nichts mehr tun in diesen Projekten erwägen wir unseren
  Appender selber als Nuget Package zu veröffentlich damit andere auch davon profitieren können.
</p>

<p>
  Der Sentry Account müsste im kommerziellen Betrieb von der SBB neu erstellt werden. Danach kann im Projekt ein
  neuer DSN (Data Source Name) generiert werden. Dieser muss dann auf dem Mini PC in der Umgebungsvariable mit dem
  Namen <code>SENTRY_DSN</code> abgelegt werden.
</p>

<h4>Interne Kommunikation</h4>
<p>
  Durch die Anbindung von verschiedenen Komponenten und die verteilte Entwicklung sowie möglicher Integration von
  weiteren Komponenten je nach Projektverlauf haben wir uns für eine Microservice Architektur entschieden. In einer
  solchen Architektur braucht es in der Regel einen Message Broker beziehungsweise eine Message Queue. Um dies
  umzusetzen haben wir auf Redis gesetzt. Der Redis Server läuft ständig auf dem Mini PC und fährt automatisch hoch
  sobald Windows startet.
</p>

<p>
  Redis kann zwar mehr als nur Broker spielen, wir brauchen diese Features allerdings nicht. Redis zeichnet sich aus
  durch die Einfachheit sowie die grosse Anzahl an production ready Bibliotheken zur Integration in alle gängingen
  und zum Teil auch nicht gängigen Technologien. Ausserdem gibt es ein Command Line Interface mit welchem bequem
  manuell Nachrichten in die Queue geschrieben werden können sowie diese auch ausgelesen werden kann.
</p>

<p>
  Der Einsatz von Redis bringt also das Pattern PubSub (Publish/Subscribe) hervor. Die entwickelten Komponenten
  laufen als eigenständige Prozesse und wissen nicht welche andere Prozesse laufen. Will eine Komponente mit einer
  anderen kommunizieren muss sie die Nachricht in die Redis Message Queue schreiben und somit publishen. Will sie
  Nachrichten lesen, muss sie sich auf eine Queue subscriben.
</p>

<p>
  Um auf der Entwicklungsumgebung nicht den Redis Server installieren zu müssen, gibt es ein Redis Docker Image
  welches den Server containerisiert startet. Somit kann eine Instanz ohne Konfiguration on Demand gestartet werden.
  Auf dem Mini PC haben wir zuerst auch mit Docker den Redis Server eingerichtet weil die Windows Version des Redis
  Servers nicht offiziell unterstützt wird von Seite Redis. Jedoch ist zum Zeitpunkt dieser Arbeit Docker immer noch
  nicht sehr stabil um Container auf einer Serverplattform laufen zu lassen. Für eine Entwicklungsumgebung ist es ok,
  aber auch nicht ideal. Deshalb haben wir dann den Redis Server der Microsoft offiziell unterstützt als
  Windowsdiesnt installiert.
</p>

<p>
  Während der Entwicklung der Komponenten haben wir uns schlussendlich auf folgende Menge an Befehlen geeinigt.
</p>

<ul>
  <li><code>capture:start {{timestamp}}</code></li>
  <li><code>capture:stop</code></li>
  <li><code>capture:abort</code></li>
  <li><code>capture:pause</code> (obsolete)</li>
  <li><code>capture:resume</code> (obsolete)</li>
  <li><code>delivery:upload {{filename}}</code></li>
  <li><code>delivery:compress {{filename}}</code></li>
  <li><code>kill</code></li>
</ul>

<p>
  Im Diagramm unten ist dargestellt wie ein Aufnahme des Zuges auf der Kommunikationsebene abläuft. Es sind sämtliche
  Nachrichten ersichtlich. Wie man sieht, geht jede Nachricht immer zuerst an den Redis Server welche sie dann weiter
  an die Komponenten, die sich darauf subscribed haben, leitet. Die einzelnen Komponenten werden später erklärt.
</p>

<figure class="full">
  <img src="images/thermoscanner/aufnahme-sequenz-diagramm.png">
  <figcaption>Sequenzdiagramm Aufnahme</figcaption>
</figure>
<!--
To generate the diagram: Go to https://www.websequencediagrams.com/ and paste the following:

title Aufnahme Sequenz

Trigger->Redis: capture:start "1"
Redis->IRReader: capture:start "1"
Redis->VisibleLightReader: capture:start "1"
Redis->TemperatureReader: capture:start "1"

Trigger->Redis: capture:stop
Redis->IRReader: capture:stop
Redis->VisibleLightReader: capture:stop
Redis->TemperatureReader: capture:stop

IRReader->Redis: delivery:compress "1-ir.seq"
Redis->IRCompressor: delivery:compress "1-ir.seq"
IRCompressor->Redis: delivery:upload "1-ir.mp4"
VisibleLightReader->Redis: delivery:upload "1-visible.mp4"
TemperatureReader->Redis: delivery:upload "1-temperature.txt"

Redis->Uploader: delivery:upload "1-ir.mp4"
Redis->Uploader: delivery:upload "1-visible.mp4"
Redis->Uploader: delivery:upload "1-temperature.txt"
-->

<h4>Komponenten Architektur</h4>
<p>
  Damit es einfach ist neue Komponenten zu erstellen, haben wir ein Common Modul erstellt welches Code bereitstellt,
  welcher für alle Komponenten der selbe ist. Im Common Modul gibt es eine abstrakte Klasse
  <code>ThermoBoxComponent</code> von welcher konkrete Komponenten erben können. Eine Komponente kann dann definieren
  welchen Kanälen Sie folgen möchte und welchen Handler sie anstössen möchte wenn eine Nachricht eintritt. Zudem gibt
  es eine Funktion um Nachrichten zu publishen.
</p>

<p>
  Die gewählte Architektur hat sich sehr bewährt. Es ermöglicht den selektiven Betrieb einzelner Komponenten so, dass
  diese isoliert getestet werden können. Zudem kann man auch mal eine Komponente ausschalten wenn man das Feature
  gerade nicht braucht. Zum Beispiel können wir den Uploader einfach nicht starten wenn wir nicht möchten, dass
  Dateien auf den Server hochgeladen werden. Es ist keine Konfigurationsänderung notwendig.
</p>

<p>
  Das einzige Problem das wir mit dieser Architektur festgestellt haben ist, dass wir Kameras haben auf welche mit
  nur einem Windows Prozess zugegriffen werden kann. Die erste Idee war, dass wir eine Komponente haben, welche die
  Farbkamera ausliest um zu erkennen ob gerade ein Zug in die Waschstrasse fährt. Eine zweite Komponente greift auf
  die selbe Kamera zu um die Bilder in ein Video aufzunehmen sobald der Zug erkannt wurde. Dies war leider nicht
  möglich. Also mussten wir in diesem konkreten und einzigen Fall vom Microservice-Pattern abweichen und beide
  Funktionalitäten in der selben Komponente implementieren.
</p>

<h4>Reader Komponenten</h4>
<p>
  Unter den Reader Komponenten verstehen sich Komponenten die eine Aufnahme tätigen oder eben einen Sensor auslesen.
  Die Reader Komponenten subscriben sich auf die Channels <code>capture:start</code>, <code>capture:stop</code> und
  <code>capture:abort</code>.</p>
<p>
  Beim Start Befehl wird ein Timestamp im Format <code>YYYY-MM-DD@HH-mm-ss</code>
  übergeben. Diesen Timestamp verwenden die Reader um einen eindeutigen Dateinamen zu erzeugen. Wenn diese Dateinamen
  später asynchron über diverse Wege wieder zusammengetragen werden können Sie wieder zusammen gruppiert werden und
  man weiss zu welcher Aufnahme sie gehören. Würden die Reader selber den Timestamp erzeugen ist durch die asynchrone
  Natur der Redis Message Queue nicht gegeben, dass die selben Timestamps zum Zuge kommen.
</p>

<p>
  Beim Stop Befehl stoppen die Reader ihre Aufnahme und schicken die erzeugte Datei an den jeweiligen Channel weiter.
</p>

<p>
  Beim Abbruch-Befehl werden die Reader die Aufnahme abbrechen und alle angefallenen Dateien aufräumen. Ein Abbruch
  kann unter anderem stattfinden wenn die Trigger Komponente sich dafür entscheidet die Aufnahme zu starten weil sie
  glaubt der Zug sei eingefahren. Später wird dann aber gemerkt, dass es ein Fehlalarm war und die Aufnahme
  abgebrochen werden sollte. Würde der Trigger warten bis er sich ganz sicher ist, könnte bereits ein Teil des Zuges
  durch gefahren sein ohne dass er aufgenommen wurde.
</p>

<p>
  Um manuelle Befehle zu geben haben wir ein Powershell Script <code>Control.ps1</code> erstellt mit welchem
  interaktiv die möglichen Befehle abgesendet werden können.
</p>

<h5>IRReader</h5>
TODO
<p>
  Die Aufgabe des IRReaders ist die Bilder FLIR Kamera aufzunehmen. Bevor die eigentliche Komponente gestartet wird,
  wird zuerst die Kamera gefunden. Die Suche nach der Kamera geschieht asynchron. Um die Testingzyklen sowie
  grundsätzlich den Start der Komponente zu beschleunigen haben wir folgendes Verfahren entwickelt um möglichst
  schnell mit der Kamera zu verbinden.
</p>

<p>
  FLIR Atlas SDK
</p>

<p>
  Zu erst wird ein Discovery Thread gestartet der in einem Event Handler auf gefundene Kameras reagiert. Wird die
  richtige Kamera gefunden welche den Suchstring matched, wird der originale Thread mit dem Resultat der Kamera
  beendet und er retourniert. Die Kamera die gefunden werden soll ist in der Konfiguration unter dem Key
  <code>IR_CAMERA_NAME</code> abgelegt. Für unsere Kamera ist diesre "FLIR AX5". Wird die Kamara nicht innerhalb von
  5 Sekunden gefunden verwenden wir die Emulator-Kamera, die das FLIR Atlas SDK anbietet, verwendet. Das heisst das
  Discovery-Verfahren dauert maximum 5 Sekunden oder kürzer.
</p>

<p>
  Die Emulatorkamera ist hilfreich wenn man die Komponente testen will ohne dass man die Kamera im Netzwerk in
  Betrieb genommen hat. Das erzeugte Bild ist ein Test-Infrarotbild bei welchem sich ein Balken auf und ab bewegt
  sowie einige Noise-Pixel die sich zufällig verteilen.
</p>

<figure>
  <img src="images/thermoscanner/kamera-emulator.jpg">
  <figcaption>Bild des FLIR ATLAS SDK Kameraemulators</figcaption>
</figure>

<figure>
  <pre><code>2018-01-11 10:51:40,520 IRReader.exe [INFO] Discovering cameras
2018-01-11 10:51:45,640 IRReader.exe [WARN] Fallback to emulator camera
2018-01-11 10:51:47,125 IRReader.exe [INFO] Stopping discovery
2018-01-11 10:51:47,125 IRReader.exe [INFO] Connecting to camera: Camera Emulator
2018-01-11 10:51:48,229 IRReader.exe [INFO] Connecting to redis on localhost
2018-01-11 10:51:48,893 IRReader.exe [INFO] Connected to redis
2018-01-11 10:51:48,894 IRReader.exe [INFO] Subscribing to cmd:capture:start
2018-01-11 10:51:48,904 IRReader.exe [INFO] Subscribing to cmd:capture:stop
2018-01-11 10:51:48,905 IRReader.exe [INFO] Subscribing to cmd:capture:abort
2018-01-11 10:51:48,905 IRReader.exe [INFO] Subscribing to cmd:capture:pause
2018-01-11 10:51:48,906 IRReader.exe [INFO] Subscribing to cmd:capture:resume
2018-01-11 10:51:48,907 IRReader.exe [INFO] Subscribing to cmd:kill</code></pre>
  <figcaption>IRReader Startup Log</figcaption>
</figure>

<p>
  Die Infrarot Kamera wird in der Regel eine Betriebstemperatur von ca. 40 - 50° C einnehmen. Die Kamera hat eine
  interne Mappingtabelle sowie ein Kalibrierungsverfahren um die Eigentemperatur zu kompensieren damit diese keine
  Einflüsse auf das aufgenommene Bild haben. Flir nennt den Prozess NUC (Non Uniformity Correction). Ein NUC dauert
  ca. 0.2 - 0.5 Sekunden und blockiert die Aufnahme. Zeichnet man Bilder auf hat man während eines NUCs ein schwarzes
  Bild. Die Standardkonfiguration der Kamera ist, dass alle 4 Minuten ein NUC gemacht wird um eventuelle sich
  veränderte Temperaturen zu kompensieren. Zusätzlich startet die Kamera den NUC wenn sich die Eigentemperatur um
  einen einstellbaren Threshold verändert hat. Gerade wenn man die Kamera in einem Büro in Betrieb nimmt, wird sie
  anfänglich ca. jede Minute einen NUC durchführen bis sie die normale Betriebstemperatur erreicht hat. Der NUC ist
  übrigens hörbar weil der Verschluss mechanisch betätigt wird. Es hört sich wie ein Klicken an.
</p>

<p>
  Wir möchten in unseren Aufnahmen keine schwarzen Frames haben. Als Lösung haben wir eingebaut, dass unmittelbar
  bevor eine Aufnahme gestartet wird ein NUC durchgeführt wird. Dann können wir davon ausgehen, sofern die Kamera
  länger als ein paar Minuten in Betrieb ist, dass der nächste NUC erst in 4 Minuten durchgeführt wird. Der
  anfängliche NUC dauert auch nicht zu lange dass wir eventuell sogar den Anfang verpassen würden. Die NUC
  Einstellungen können via dia Parameter <code>NUCMode</code>, <code>NUCTempDelta</code> und
  <code>NUCIntervalFrames</code> eingerichtet werden.
</p>

<p>
  Die Aufnahme steuern wir über den FLIR ATLAS SDK Recorder. Dieser kann Videos von der Kamera aufnehmen. Diese
  werden im FLIR proprietären Format SEQ abgespeichert. Das SEQ Format ist nichts anderes als aneinandergehängte TIFF
  Dateien welche mit Rohdaten der Kamera befüllt sind. Zusätzlich gibt es EXIF Metadaten. Da die Kamera mit 14 bit
  aufnimmt und keine Kompression stattfindet, sind die resultierenden Dateien sehr gross. Es gibt keine Möglichkeit
  die Bilder sofort zu komprimieren.
</p>

<figure>
  <img src="images/thermoscanner/seq-filesize-formula.png">
  <figcaption>Formel zur Berechnung der SEQ-Dateigrösse</figcaption>
</figure>

<p>
  Nehmen wir in der vollen Auflösung und Framerate auf werden die Dateien schnell so gross, dass sie gar nicht mehr
  der Disk Platz hätten. Deshalb haben wir die Framerate auf ein Frame pro Sekunde verringert. Die Auflösung zu
  verringern macht kein Sinn weil wir dann Bilddetails verlieren.
</p>

<p>
  Die Kontrolle der Kamera über das FLIR ATLAS SDK ist etwas mühsam. Zum einen muss das SDK manuell heruntergeladen
  und installiert werden. Es gibt kein Nuget Package. Zum anderen ist die Control-Library nicht sehr stabil. Es kann
  zu zufälligen Exceptions kommen wenn ein Befehl abgesetzt wird. Um uns Abhilfe zu schaffen haben wir eine Retry
  Methode gebaut der ein Callback zur Befehlsausführung mitgegeben wird sowie ein Callback zur Überprüfung ob es
  erfolgreich war. Diese Retry Methode für dann den Befehl so lange wiederholt aus bis keine Exception geworfen wird
  und der zweite Callback sagt, dass es funktioniert hat. Leider können wir nicht in den Code hineinschauen weil er
  propriertär und obfuscated ist.
</p>

<figure>
  <pre><code>/// &lt;summary&gt;
/// Tries to execute an action. If an exception is thrown, it tries again until a
/// threshold is reached.
/// &lt;/summary&gt;
/// &lt;param name="action"&gt;Action with potential exception thrown</param>
    /// &lt;param name="testSuccess"&gt;Function to test the success of the action</param>
    private static void Retry(Action action, Func&lt;bool&gt; testSuccess)
{
  var tries = 0;
  const int maxTries = 5;

  while (tries < maxTries)
  {
    try
    {
      action.Invoke();

      if (testSuccess.Invoke())
      {
        return;
      }

      throw new Exception("Camera state was not as expected");
    }
    catch (Exception ex)
    {
      Log.Warn("Exception while executing camera command", ex);
    }

    tries++;
    Log.Warn($"Failed executing camera command (try {tries} of {maxTries})");
    Thread.Sleep(10);
  }

  Log.Error($"Could not execute command after {tries} tries.");
}</code></pre>
  <figcaption>FLIR ATLAS SDK Code zur wiederholten Befehlsausführung</figcaption>
</figure>

<p>
  Wird die Aufnahme gestoppt erzeugt der IRReader drei Dateien.
</p>

<ul>
  <li>SEQ Datei: Video-Rohdaten</li>
  <li>JPG Datei: Snapshot des ersten Frames des Videos</li>
  <li>JSON Datei: Aktuelle Device Parameter</li>
</ul>

<p>
  Die SEQ Datei wird via <code>delivery:compress</code> an den IRCompressor übergeben welcher die Datei komprimiert
  damit dieser übertragen werden kann. Das übertragen der Rohdaten ist erstens zu langsam weil Züge schneller
  vorbeifahren als wir hochladen könnten und zweitens haben wir nicht genügend Serverspeicherplatz im die Dateien
  abzuspeichern. Zu beachten ist, dass die SEQ Datei nur die Sensorwerte enthält. Es sind noch keine Temperaturwerte
  darin. Um diese zu Berechnen müssen weitere Parameter hinzugenommen werden.
</p>

<p>
  Die JPG Datei dient uns zum Vergleich des komprimierten Videos. Damit sehen wir ob der Kompressionsalgorithmus
  keine offensichtlichen Fehler beinhaltet. Weiter dauert das Kompressionsverfahren sowie der Upload einige Zeit.
  Möchten wir trotzdem schon sehen was aufgenommen wurde müssten wir warten. Dieser Snapshot kann allerdings sehr
  schnell und ohne langwirige Kompression hochgeladen werden. So sehen wir direkt ob und welcher Zug sich im Bild
  befindet.
</p>

<p>
  Die JSON Datei enthält die 315 verfügbaren Geräteparameter der FLIR A65 Kamera die zur Zeit der Aufnahme
  konfiguriert waren. Je nach Einstellung resultieren andere Bilder. So gibt es zum Beispiel einen High Gain oder Low
  Gain Modus. Diese Angaben dienen uns als Kontext bei der Interpretation und weiterverarbeitung der aufgenommenen
  Bilder. Wir speichern diese Informationen bei jeder Aufnahme mit ab. Enthalten sind auch Sensorinformationen der
  Kamera wie z.B. Gehäuse- oder Sensortemperatur. Zur Serialisierung der Kameraparamter haben wir eigene Modelklassen
  geschrieben die wir befüllen und dann mit <a href="#ref-json-net">Json.NET</a> serialisieren.
</p>

<p>
  Hier ein Auszug aus den Parametern die für uns zum Teil relevant sind:
</p>

<figure>
  <code>DeviceVendorName, DeviceModelName, DeviceManufacturerInfo, DeviceVersion, DeviceID, DeviceUserID,
    DeviceScanType, DeviceTemperatureSelector, DeviceTemperature, CameraFirmwareVersion,
    SensorFirmwareVersion, SensorResolution, SensorFocalLength, SensorFrameRate, SensorTemperature,
    HousingTemperature, CameraOptions, SensorWidth, SensorHeight, SensorDigitizationTaps, WidthMax, HeightMax, Width,
    Height, OffsetX, OffsetY, BinningHorizontal, BinningVertical, DecimationHorizontal, DecimationVertical, PixelFormat,
    PixelCoding, PixelSize, PixelColorFilter, AcquisitionMode, AcquisitionFrameCount, LineSelector,
    LineMode, UserOutputSelector, LineDebounceFactor, SyncMode, SensorGainMode, NUCMode, NUCTempDelta,
    NUCIntervalFrames, BaudRate, ShutterPosition, CorrectionMask, R, Spot, B, F, O, FNumber,
    Transmission, OInt, TemperatureLinearMode, TemperatureLinearResolution, RThg, J1, OAShift, ObjectEmissivity,
    ReflectedTemperature, WindowTransmission, WindowTemperature, AtmosphericTransmission, AtmosphericTemperature,
    SensorVideoStandard, ImageAdjustMethod, VideoOrientation, PlateauLevel, MaxAGCGain</code>
</figure>

<h5>VisibleLightReader</h5>
TODO
<p>
  Liest Bilder der Basler Kamera aus.
</p>

<h5>TemperatureReader</h5>
TODO
<p>

</p>

<h5>WeatherReader</h5>
<p>
  In der zweiten Aufnahmephase haben wir uns entschieden den TemperatureReader nicht mehr zu verwenden weil die
  Messdaten nicht brauchbar sind. Um die aufgenommenen IR Bilder trotzdem auswerten zu können haben wir den
  WeatherReader implementiert der aktuelle Wetterdaten von <a href="#ref-openweathermap">OpenWeatherMap</a>
  herunterlädt.
</p>

<p>
  OpenWeatherMap bietet eine gratis API an um das aktuelle Wetter abzufragen. Um alte Daten abzufragen müsste man
  bezahlen. Deswegen haben wir uns entschieden die Daten jeweils dann abzufragen wann die Aufnahme gemacht wird.
  Durch das müssen wir nicht bezahlen. Die Daten können über einen HTTP GET Request abgefragt werden:
</p>

<figure>
  <pre><code>http://api.openweathermap.org/data/2.5/weather?q=Zürich,CH&appid={openWeatherMapApiKey}</code></pre>
  <figcaption>OpenWeatherMap API Request URL</figcaption>
</figure>

<p>
  Die Antwort die zurück kommt sieht dann ungefähr so aus:
</p>

<figure>
  <pre><code>{
  "coord": {"lon": 8.54, "lat": 47.37},
  "weather": [{
    "id": 802,
    "main": "Clouds",
    "description": "scattered clouds",
    "icon": "03n"
  }],
  "main": {
    "temp": 280.06,
    "pressure": 1016,
    "humidity": 71,
    "temp_min": 276.15,
    "temp_max": 284.15
  },
  "visibility": 10000,
  "wind": {"speed": 7.2, "deg": 240},
  "clouds": {"all": 40},
  "dt": 1514697600,
  "sys": {
    "sunrise": 1514704386,
    "sunset": 1514735106
  }
}</code></pre>
  <figcaption>OpenWeatherMap API Response</figcaption>
</figure>

<p>
  Der WeatherReader setzt eine Internetverbindung voraus. In der Zeit als das LTE Modul ausgefallen ist, hatten wir
  somit keine Wetterdaten sammeln können. Die Rate Limits der Gratis API Subsciprtion schränken uns mit 60 Calls pro
  Minute nicht ein. Etwas unschön ist, dass die Wetterdaten nur alle 2 Stunden aktualisiert werden wenn man nicht zahlt.
</p>

<p>
  Der API Key wird auf dem Mini PC in der Umgebungsvariable <code>OPEN_WEATHER_MAP_API_KEY</code> abgelegt, damit
  dieser nicht in einer im Repository eingecheckten Datei gespeichert werden muss.
</p>

<h4>Delivery Komponenten</h4>

<h5>IRCompressor</h5>
TODO
<p>

</p>

<h5>Uploader</h5>
<p>
  Die Uploader Komponente hört auf Nachrichten im Kanal <code>delivery:upload</code>. Die Dateien werden auf einen
  FTP Server hochgeladen und anschliessend in den Papierkorb verschoben. Die Zugagngsdaten zum FTP Server sind in der
  Umgebungsvariable <code>THERMOBOX_FTP</code> abgelegt in der Form <code>username:password@server</code>.
</p>
<p>
  Die Dateien werden anschliessend nicht einfach gelöscht sondern in den Papierkorb verschoben weil sich so die
  Möglichkeit bietet nachzuschauen welche Dateien genau auf dem Mini PC existiert haben weil vielleicht etwas mit dem
  Upload schiefgegangen ist. Auf Windows kann dann eingestellt werden wie gross der Inhalt des Papierkorbs maximal
  sein darf. Ist das Limit überschritten leer Windows automatisch die ältesten Dateien. So können wir den
  Festplattenspeicherplatz optimal ausnutzen und trotzdem sicherstellen, dass sie nie voll läuft. Ausser ein Programm
  erstellt eine einzige Datei die den verfügbaren Speicherplatz alleine ausnutzt.
</p>

<p>
  Um Dateien von einer .NET Applikation in den Papierkorb zu verschieben, gibt es leider kein einfaches Interface.
  Zum einen kann man ein Shell32 Objekt erstellen welches auf den Papierkorb zeigt und die Datei dann dort
  hinverschieben. Damit das klappt muss man aber zuerst in einem STA Thread (single-threaded apartment) sein, welches
  unsere Komponenten nicht sind.
</p>

<p>
  Die auf den FTP Server hochgeladenen Dateien lesen wir dann im Thermobox Cockpit aus und zeigen sie im Browser an.
  So kann live mitverfolgt werden was gerade aufgenommen wurde.
</p>

<h4>CLI Utils</h4>
TODO
<p>

</p>

<h5>SeqConverter</h5>
TODO
<p>
  Das SeqConverter CLI Programm dient zur Konvertierung von FLIR SEQ Dateien zu MP4 oder umgekehrt.
</p>

<h5>ExtractFrames</h5>
TODO
<p>
  Das ExtractFrames diente uns während der Nachbearbeitung und zur Erstellung von kurzen Testvideos anhand unseres
  Testmaterials. Dieses Tool kann schnell n Frames aus einem Video extrahieren und in einem Ordner ablegen.
</p>


<h4>Thermoboard Cockpit</h4>
TODO
<p>

</p>


<p id="ref-openweathermap" class="reference-item">
  <span class="ref">OpenWeatherMap: Wetter API</span>
  <a href="http://openweathermap.org" target="_blank">http://openweathermap.org</a>
  <span class="retrieved">10. Januar 2018</span>
</p>

<p id="ref-json-net" class="reference-item">
  <span class="ref">Json.NET: .NET API für JSON</span>
  <a href="https://www.newtonsoft.com/json" target="_blank">https://www.newtonsoft.com/json</a>
  <span class="retrieved">11. Januar 2018</span>
</p>
