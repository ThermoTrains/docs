<h3>Software</h3>

<h4>Software Landschaft</h4>

<ul>
  <li>Thermobox</li>
  <li>Sentry</li>
  <li>Cockpit</li>
  <li>Thermoboard</li>
  <li>Github</li>
  <li>GitHub</li>
  <li>Teamviewer</li>
</ul>

<p>
  Um die vielfältigen Anforderung an die Entwicklung der Software abzudecken haben wir über den Verlauf dieser Arbeit
  eine ganze Software-Landschaft aufgebaut um unsere Hardware.
</p>

TODO Diagramm

<h4>Technologie</h4>

TODO diese Tabelle eventuell weiter oben als übersicht?

<figure>
  <table>
    <thead>
    <tr>
      <th>Repository</th>
      <th>Sprachen</th>
      <th>Frameworks</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td><code>thermobox</code></td>
      <td>C#, Powershell, Batch</td>
      <td>.NET, FLIR Atlas, Basler Pylon, EMGU.CV, Raven, Log4Net</td>
    </tr>
    <tr>
      <td><code>thermoboard</code></td>
      <td>PHP, Typescript</td>
      <td>Laravel, Angular</td>
    </tr>
    <tr>
      <td><code>thermobox-cockpit</code></td>
      <td>PHP, HTML</td>
      <td>keine</td>
    </tr>
    <tr>
      <td><code>supersimplemonitoring</code></td>
      <td>PHP, HTML</td>
      <td>Chart.JS</td>
    </tr>
    <tr>
      <td><code>research</code></td>
      <td>Matlab</td>
      <td>keine</td>
    </tr>
    <tr>
      <td><code>post-processing</code></td>
      <td>Java</td>
      <td>OpenCV</td>
    </tr>
    </tbody>
  </table>
  <figcaption>Übersicht Code Repositories</figcaption>
</figure>

<h5>Continous Integration</h5>
<p>
  Zu einem guten Entwicklungsprozess gehört Continuous Integration. Da es für die zu verwendeten Technologien und
  Frameworks keine gratis Dienste gibt und wir selber keine Server besitzen die diese Aufgabe übernehmen könnten,
  haben wir die Thermobox selber als Continuous Integration Server eingesetzt. Startet die Thermobox wird automatisch
  der HEAD commit aus dem Git repository auf dem master Branch ausgecheckt. Dann werden die Nuget Dependencies
  aktualisiert. Somit kann anschliessend der Release Build durchgeführt werden. Alle Assemblies erhalten die korrekte
  Versionsnummer die im Repository in der Datei <code>SharedAssemblyInfo.cs</code> eingecheckt ist. Weil wir aber
  nicht andauernd die Version erhöhen möchten um diese bauen zu lassen, hängen wir auch den Commit Hash hinten daran.
  Dieser String kann mit folgendem Git Befehl erzeugt werden:
</p>

<figure>
  <pre><code>git describe --long --tags</code></pre>
  <figcaption>Version mit Git Commit Hash erzeugen Befehl</figcaption>
</figure>

<p>
  Dies erzeugt einen String wie diesen: <code>1.0.0-52-ge078b31</code>. Diese Versionsnummer ist deswegen wichtig
  weil wir in den Logs auf diese zurückgreifen. Dazu mehr im Kapitel <a href="#thermobox-logging">Logging</a>.
</p>

<h5>Unit Testing</h5>
<p>
  Um die verschiedenen Komponenten und insbesondere die Bildanalyse Algorithmen zu entwickeln haben wir wo es sind
  macht, TDD (Test Driven Development) eingesetzt. Seit Visual Studio 2017 Update 5 gibt es in der Enterprise Edition
  (welche wir über Microsoft Imagine via Schulaccount beziehen können) Live Unit Testing. Dieses nette Feature
  erkennt live welche Unit Tests von der Code Änderung betroffen sind und führt diese nach einem Build automatisch
  aus. Das Resultat wird gleich links leben den Zeilennummern im Editor angezeigt.
</p>

<figure>
  <img src="images/thermoscanner/screenshot-live-unit-testing.png">
  <figcaption>Screenshot Live Unit Testing</figcaption>
</figure>

<p>
  Zu beachten ist, dass Visual Studio dabei sämtliche Dateiänderungen folgt. In unserem Build wurde anfänglich
  jedesmal die Datei <code>SharedVersionInfo.cs</code> generiert welche die aktuelle Versionsnummer enthält. Dies hat
  den Build jedes mal neu getriggert. Somit hat Visual Studio non-Stopp gebuilded und die Unit Tests ausgeführt. Nach
  dem hilfreichen Feedback auf eine <a
  href="https://developercommunity.visualstudio.com/content/problem/152749/live-unit-testing-rebuilding-non-stop.html">Frage
  in der Visual Studio Developer Community</a> konnten wir aber auch diesen Issue beheben in dem wir den Build nur
  triggern wenn es die Datei noch nicht gibt. Zudem löschen wir diese zu Beginn eines Builds damit sie dann auch
  wirklich neu generiert wird.
</p>

<h5 id="thermobox-logging">Logging</h5>
<p>
  Um auch später nachvollziehen zu können was in der Software passiert, ist ein umfängliches Logging unumgänglich.
  Wir setzen dazu log4net ein. Die Konfiguration des Loggings ist für alle Konfigurationen die selbe und wird
  geteilt. Somit müssen kleine Anpassungen an der Konfiguration nicht über all nachvollzogen werden. Die Log Dateien
  werden pro Komponente in eine Datei im Pfad <code>C:\Thermobox\logs\</code> abgelegt. Eine Zeile im Log enthält
  folgende Informationen:
</p>

<ul>
  <li>Datum</li>
  <li>Uhrzeit auf die Millisekunde genau</li>
  <li>Assembly Name</li>
  <li>Version</li>
  <li>Git Commit Hash</li>
  <li>Log Level</li>
  <li>Nachricht</li>
</ul>

<p>
  Eine Log Zeile sind dann als Beispiel so aus:
</p>

<figure>
  <pre><code>2017-11-20 09:06:44,724 TemperatureReader.exe-1.0.0-1-gb652480
    [INFO] Received message on channel cmd:capture:start: 2017-11-20@09-06-44</code></pre>
  <figcaption>Beispiel Log Zeile</figcaption>
</figure>

<p>
  Wird eine Log Datei zu gross wird diese automatisch umbenannt und es wird eine neue Datei begonnen. Wir haben ein
  Threshold von 10 MiB gewählt. Dieser wurde eigentlich nur von der VisibleLightReader-Komponente erreicht weil wir
  dort Debug Logs um den Detektionsalgorithmus laufend zu verbessern. Gesamthaft haben wir über die zwei Testphasen
  ca. 154 MiB an Logdateien gesammelt.
</p>

<p>
  Auf einer Logzeile wird der Assembly Name aufgeführt. Dies mag redundant erscheinen weil dieser ja auch bereits in
  der Logdatei enthalten ist. Allerdings starten mit dem Start Script alle Komponenten miteinander und lassen diese
  auch auf die selbe Konsole schreiben damit man nicht 6 verschiedene Fenster offen und überwachen muss. Im
  Normalbetrieb starten die Komponenten im Hintergrund. Somit hätte man eigentlich keine Möglichkeit die Logs
  aggregiert zu sehen. Man kann höchstens ein <code>tail</code> auf die einzelnen Dateien machen. Also haben wir ein
  Powershell Script geschrieben, dass sämtliche Logdateien folgt. Zudem färbt es die verschiedenen Loglevels auch
  gleich ein. Also erscheint eine Exception auch gleich rot. Die Entwicklung des Scripts war nicht ganz einfach weil
  pro Logdatei ein Thread gestartet werden muss der einer einzelnen Logdatei folgt und dessen neuen Logs zurück auf
  die Hauptkonsole schreibt. Diese Lösung könnte eventuell auch für andere Projekte interessant sein.
</p>

<p>
  Um das Logging muss man sich bei einem Wiederbetrieb der Kabine als erstes nicht kümmern. Logs werden nur lokal
  abgelegt. Auch die Scripts zur aggregierten Ansicht der Logs gehen nehmen zusätzliche Komponenten Logs automatisch
  auf.
</p>

<h5>Remote Access</h5>
<p>
  Um von Fern auf den Mini-PC und die Hardware zu zugreifen, haben wir einen Teamviewer Server installiert. Dieser
  ermöglicht es mit einer Partner ID und einem Passwort darauf zuzugreifen. Teamviewer bietet das beste
  Benutzererlebnis verschiedenster Remote Access Lösungen. Auf die Standard Windows Remote Desktop Lösung können wir
  nicht zugreifen, weil der Server direkt mit einer IP im Internet angebunden ist welche nicht statisch ist.
  Teamviewer darf für nicht kommerzielle Zwecke gratis eingesetzt werden. Sobald die SBB das Projekt weiterführt,
  müsste ein Lizenz angeschafft werden sofern noch keine bestehen.
</p>

<h5>Hardware Monitoring</h5>
<p>
  Wir stellen unsere Hardware an einem Ort auf an dem es externe Einflüsse gibt die wir nicht unter Kontrolle haben.
  So kann z.B. jemand den Kasten ausstecken, Regen kann hineingelangen und einen Kurzschluss erzeugen oder er
  verliert die Netzwerkkonnektivität. Wir möchten also überwachen können ob die Thermobox läuft. Also brauchen wir
  ein Tool zur Überwachung der Uptime.
</p>

<p>
  Weiter möchten wir die Temperatur der Hardware überwachen um eventuelle Konstruktionsbedingte Wärmestaus frühzeitig
  zu erkennen bevor es anfängt zu schmelzen. Die Hardware ist draussen und kann nur in den vorgebenenen Temperaturen
  betrieben werden. Durch eine Fehlfunktion des Heizlüfters oder Thermostats könnte des Innere des Gehäuses auch
  überhitzt werden. Oder der Mini PC erzeugt eventuell so viel Hitze, dass diese nicht abgebaut werden kann. Einen
  Lüftungsschlitz nach aussen gibt es nämlich nicht. Die einzige undichte Ort ist der Kabelschlitz im Boden des
  Gehäuses. Also möchten wir die Temperatur des Mini-PCs überwachen können.
</p>

<p>
  Um Erkenntnisse über die Performance der Software Suite zu gelangen und eventuell zu erkennen, dass das System
  überlastet ist möchten wir auch die CPU Last sowie den Memory Verbrauch analysieren können. Die
  Performance-intensivsten Abläufe sind folgende:
</p>

<ul>
  <li>Bildanalyse ob ein Zug im Bild ist</li>
  <li>Aufnahme Full HD Farbvideo mit Live H.264 Kompression</li>
  <li>Aufnahme Infrarot Bilder</li>
  <li>Clamping Infrarot Bilder von 16 bits zu 8 bits</li>
  <li>Nachträgliche H.264 Kompression der Infrarot Bilder</li>
</ul>

<p>
  Diese Abläufe können sich auch in die Quere kommen was wir erkennen möchten. Zudem möchten wir erkennen wenn der
  Arbeitsspeicher ausgeht und eventuell auf die Disk geswapped wird.
</p>

<p>
  Um diese Daten aufzunehmen haben wir nach einer Monitoring Lösung gesucht. Dazu gibt es diverse Self-Hosting
  Lösungen wie z.B. das alt bekannte Nagios wovon es mittlerweile auch schon diverse Forks gibt. Diese Lösungen
  können wir allerdings nicht selber betreiben weil uns die Server dazu fehlen. Ausserdem ist ein solches System
  dafür ausgelegt eine ganze Serverlandschaft zu überwachen und nicht nur einen einzigen. Deswegen ist die
  Installation und Konfiguration einer solchen Lösung sehr aufwändig. Diesen Aufwand wollten wir uns wenn möglich
  sparen.
</p>

<p>
  Die andere Option ist eine SaaS Monitoring Lösung zu verwenden. Das Problem hierbei ist, dass es keine Anbieter
  gibt die das gratis machen. Oder jedenfalls nicht so, dass wir mehrere Monate lang auf den Server zugreifen können.
</p>

<p>
  Deswegen haben wir uns entschlossen eine eigene Lösung zu schaffen die wir auf dem Server von Sebastian Häni hosten
  können. Die entworfene Lösung ist so simpel gehalten wie möglich und ist nicht sehr erweiterbar. Die Funktionsweise
  ist so, dass die Thermobox alle 5 Minuten ein Datentupel im JSON Format mit folgenden Werten an den Server per HTTP
  POST schickt:
</p>

<ul>
  <li>CPU Temperaturen in Celsius pro Core</li>
  <li>CPU Auslastung in Prozent pro Core</li>
  <li>Memory Auslastung in Prozent</li>
  <li>Freier Festplattenspeicher in Bytes</li>
  <li>Hostname</li>
</ul>

<p>
  Der Server hängt das Datentupel an eine Datei. Das Frontend liest dann diese Datei aus und erzeugt eine HTML Seite
  die vier Graphen im Browser darstellt. Oben links wird dargestellt ob die Box online ist. Oben rechts werden die
  CPU Auslastung sowie die CPU Temperatur überlagert dargstellt. Unten links sieht man die Memory Auslastung. Und
  unten rechts sieht man den Verlauf des freien Speicherplatzes.
</p>

<figure>
  <img src="images/thermoscanner/monitoring-screenshot.jpg">
  <figcaption>Screenshot Monitoring</figcaption>
</figure>

<p>
  Der Source Code ist ausnahmsweise nicht im ThermoTrains Github Repository eingecheckt, weil diese Lösung nicht
  spezifisch für dieses Projekt funktionieren kann. Im Code ist nichts spezifisches was auf dieses Projekt hinweist.
  Das Repository kann unter <a href="https://github.com/sebastianhaeni/supersimplemonitoring">
  https://github.com/sebastianhaeni/supersimplemonitoring</a> gefunden werden.
</p>

<p>
  Weil es ab und zu vorkam, dass die Software nicht so funktionierte wie gewünscht, hat sich die Festplatte gefüllt
  und es konnten keine Aufnahmen mehr gemacht werden. Um sofort reagieren zu können wenn dies bald der Fall sein
  wird, schickt der Server eine E-Mail mit der Information, dass weniger als 5 GiB freier Speicherplatz zur Verfügung
  ist.
</p>

<figure>
  <img src="images/thermoscanner/screenshot-monitoring-email.png">
  <figcaption>Screenshot Monitoring E-Mail Benachrichtigung</figcaption>
</figure>

<p>
  Die Anforderungen an den Monitoring Server sind folgende:
</p>

<ul>
  <li>PHP 7+</li>
  <li>Schreibberechtigung auf <code>data/stats.txt</code></li>
</ul>

<p>
  Um den Server in Betrieb zu nehmen müssen nur die Sourcen auf den Webserver kopiert werden und die
  Schreibberechtigung eingerichtet werden. Im <code>ping.ps1</code> Script muss die richtige URL konfigurtiert werden
  damit die Datentupel an den richtigen Ort gelangen. Es gibt kein Mechanismus die alten Daten zu löschen. Dazu muss
  manuell die Datei <code>stats.txt</code> geleert werden. Die Graphen stellen jeweils nur die letzten 48 Stunden
  dar. Details über ältere Posts können mit dem Button "Show more" angezeigt werden.
</p>

<p>
  Der Client, also in unserem Fall der Thermo-Scanner, führt das Script <code>ping.ps1</code>, welches ebenfalls im
  Repository zu finden ist, alle 5 Minuten aus. Dieser allgemein als Cron-Job bekannte Prozess kann auf dem Mini-PC
  auf welchem Windows 10 läuft mit dem Task Scheduler gesteuert werden. Folgend zwei Screenshots wie der Task
  konfiguriert wurde:
</p>

<figure>
  <img src="images/thermoscanner/monitoring-task-configuration-1.png">
  <figcaption>Konfiguration Monitoring Ping Task Generell</figcaption>
</figure>

<figure>
  <img src="images/thermoscanner/monitoring-task-configuration-2.png">
  <figcaption>Konfiguration Monitoring Ping Task Trigger</figcaption>
</figure>

<p>
  Im Register Actions wurde eine Action hinzugefügt. Diese ist vom Typ "Start a program". Das Programm ist
  <code>powershell</code> und die Argumente sind
  <code>-NoLogo -File C:\repos\thermotrains\src\main\csharp\Scripts\ping.ps1 -WindowStyle Hidden"</code>.
</p>

<p>
  Das Ping Script <code>ping.ps1</code> ist in Powershell geschrieben. Es liest die CPU Temperaturen, CPU
  Auslastungen und die Memory Auslastung vom OpenHardwareMonitor aus. Um diese Angaben zuverlässig und einfach
  auslesen zu können gibt es von Windows leider keine vorgegebenen Befehler oder Services. Das Auslesen des
  verbleibenden Speicherplatzes ist jedoch mit Powershell Hausmitteln möglich.
</p>

<p>
  Eine generell funktionierende Lösung um die Sensoren der Hardware auszulesen gibt es nicht. Jeder Hersteller
  prorammiert in seinen Treibern eigene Interfaces um die Werte auszulesen. Die Software OpenHardwareMonitor versucht
  diese verschiedenen Interfaces zusammen zu tragen und stellt diese im einfachen Tool dar. Zusätzlich bietet
  OpenHardwareMonitor die Option an beim Systemstart sich selber im Tray auszuführen. Dies haben wir auf dem Mini-PC
  so konfiguriert. Wenn OpenHardwareMonitor läuft, kann über die angebotenen WMI Objekte (Windows Managment
  Instrumentation) auf die Sensor Werte mit simplen Queries zugegriffen werden. Als Beispiel hier ein Befehl welcher
  alle CPU Kern Temperaturen in Kelvin ausliest:
</p>

<figure>
  <pre><code>$temp = Get-WmiObject -Namespace "root/OpenHardwareMonitor" Sensor `
  | Where-Object {$_.SensorType -eq 'Temperature' -and $_.Name -like 'CPU Core #*'} `
  | Select-Object Value `
  | ForEach-Object {$_.Value}</code></pre>
  <figcaption>CPU Temperatur Auslesen Powershell Script</figcaption>
</figure>

<figure>
  <img src="images/thermoscanner/screenshot-openhardwaremonitor.png">
  <figcaption>Screenshot OpenHardwareMonitor</figcaption>
</figure>

<h5>Error Monitoring</h5>
<p>
  In den jeweiligen Komponenten können Errors und Warnungen geloggt oder gar uncatchted Exceptions auftreten. Um
  diese nicht mühsam im Log suchen zu müssen sollen diese einfacher eingesehen werden können. Zudem sollte bei neuen
  Fehler gleich eine E-Mail Benachrichtigung versendet werden.
</p>

<p>
  Dazu haben wir Sentry integriert. Sentry ist ein Dienst, welcher selber gehosted werden kann oder auf sentry.io
  betrieben wird. Da die Gratis-Lizenz mit ihren Einschränkungen für uns gut reicht, müssen wir keine Kosten
  aufwenden. Wenn eine Warnung oder Fehler auftritt, wird dieses Event an die Sentry API gemeldet. Sentry aggregiert
  dann die Events zusammen und schickt bei neuen unentdeckten Events eine E-Mail an uns.
</p>

<figure>
  <img src="images/thermoscanner/screenshot-sentry.png">
  <figcaption>Screenshot Sentry</figcaption>
</figure>

<p>
  Der Dienst ermöglicht es uns die Fehler sofort zu beheben nachdem sie aufgetreten sind. Zudem können wir die
  Warnungen dazu benutzen um zu sehen wie häufig und wann gewisse Meldungen auftauchen. Zum Beispiel schicken wir
  immer eine Warnung wenn ein Zug entdeckt wurde dieser aber "anscheinenden" nach zu kurzer Zeit schon wieder aus dem
  Bild gefahren ist, dass das eigentlich gar nicht möglich ist. Wenn wir dann sehen, dass das immer während der
  Dämmerung passiert ist das ein guter Hinweis was womöglich mit der Bildanalyse schief läuft.
</p>

<p>
  Um Sentry einzubinden mussten wir einen eigenen log4net Appender bauen. Die existierenden Appender sind zu alt und
  werden nicht mehr gewartet. Sollte sich in naher Zukunft nichts mehr tun in diesen Projekten erwägen wir unseren
  Appender selber als Nuget Package zu veröffentlich damit andere auch davon profitieren können.
</p>

<p>
  Der Sentry Account müsste im kommerziellen Betrieb von der SBB neu erstellt werden. Danach kann im Projekt ein
  neuer DSN (Data Source Name) generiert werden. Dieser muss dann auf dem Mini PC in der Umgebungsvariable mit dem
  Namen <code>SENTRY_DSN</code> abgelegt werden.
</p>

<h4>Interne Kommunikation</h4>
<p>
  Durch die Anbindung von verschiedenen Komponenten und die verteilte Entwicklung sowie möglicher Integration von
  weiteren Komponenten je nach Projektverlauf haben wir uns für eine Microservice Architektur entschieden. In einer
  solchen Architektur braucht es in der Regel einen Message Broker beziehungsweise eine Message Queue. Um dies
  umzusetzen haben wir auf Redis gesetzt. Der Redis Server läuft ständig auf dem Mini PC und fährt automatisch hoch
  sobald Windows startet.
</p>

<p>
  Redis kann zwar mehr als nur Broker spielen, wir brauchen diese Features allerdings nicht. Redis zeichnet sich aus
  durch die Einfachheit sowie die grosse Anzahl an production ready Bibliotheken zur Integration in alle gängingen
  und zum Teil auch nicht gängigen Technologien. Ausserdem gibt es ein Command Line Interface mit welchem bequem
  manuell Nachrichten in die Queue geschrieben werden können sowie diese auch ausgelesen werden kann.
</p>

<p>
  Der Einsatz von Redis bringt also das Pattern PubSub (Publish/Subscribe) hervor. Die entwickelten Komponenten
  laufen als eigenständige Prozesse und wissen nicht welche andere Prozesse laufen. Will eine Komponente mit einer
  anderen kommunizieren muss sie die Nachricht in die Redis Message Queue schreiben und somit publishen. Will sie
  Nachrichten lesen, muss sie sich auf eine Queue subscriben.
</p>

<p>
  Um auf der Entwicklungsumgebung nicht den Redis Server installieren zu müssen, gibt es ein Redis Docker Image
  welches den Server containerisiert startet. Somit kann eine Instanz ohne Konfiguration on Demand gestartet werden.
  Auf dem Mini PC haben wir zuerst auch mit Docker den Redis Server eingerichtet weil die Windows Version des Redis
  Servers nicht offiziell unterstützt wird von Seite Redis. Jedoch ist zum Zeitpunkt dieser Arbeit Docker immer noch
  nicht sehr stabil um Container auf einer Serverplattform laufen zu lassen. Für eine Entwicklungsumgebung ist es ok,
  aber auch nicht ideal. Deshalb haben wir dann den Redis Server der Microsoft offiziell unterstützt als
  Windowsdiesnt installiert.
</p>

<p>
  Während der Entwicklung der Komponenten haben wir uns schlussendlich auf folgende Menge an Befehlen geeinigt.
</p>

<ul>
  <li><code>capture:start {{timestamp}}</code></li>
  <li><code>capture:stop</code></li>
  <li><code>capture:abort</code></li>
  <li><code>capture:pause</code> (obsolete)</li>
  <li><code>capture:resume</code> (obsolete)</li>
  <li><code>delivery:upload {{filename}}</code></li>
  <li><code>delivery:compress {{filename}}</code></li>
  <li><code>kill</code></li>
</ul>

<p>
  Im Diagramm unten ist dargestellt wie ein Aufnahme des Zuges auf der Kommunikationsebene abläuft. Es sind sämtliche
  Nachrichten ersichtlich. Wie man sieht, geht jede Nachricht immer zuerst an den Redis Server welche sie dann weiter
  an die Komponenten, die sich darauf subscribed haben, leitet. Die einzelnen Komponenten werden später erklärt.
</p>

<figure class="full">
  <img src="images/thermoscanner/aufnahme-sequenz-diagramm.png">
  <figcaption>Sequenzdiagramm Aufnahme</figcaption>
</figure>
<!--
To generate the diagram: Go to https://www.websequencediagrams.com/ and paste the following:

title Aufnahme Sequenz

Trigger->Redis: capture:start "1"
Redis->IRReader: capture:start "1"
Redis->VisibleLightReader: capture:start "1"
Redis->TemperatureReader: capture:start "1"

Trigger->Redis: capture:stop
Redis->IRReader: capture:stop
Redis->VisibleLightReader: capture:stop
Redis->TemperatureReader: capture:stop

IRReader->Redis: delivery:compress "1-ir.seq"
Redis->IRCompressor: delivery:compress "1-ir.seq"
IRCompressor->Redis: delivery:upload "1-ir.mp4"
VisibleLightReader->Redis: delivery:upload "1-visible.mp4"
TemperatureReader->Redis: delivery:upload "1-temperature.txt"

Redis->Uploader: delivery:upload "1-ir.mp4"
Redis->Uploader: delivery:upload "1-visible.mp4"
Redis->Uploader: delivery:upload "1-temperature.txt"
-->

<h4>Komponenten Architektur</h4>
<p>
  Damit es einfach ist neue Komponenten zu erstellen, haben wir ein Common Modul erstellt welches Code bereitstellt,
  welcher für alle Komponenten der selbe ist. Im Common Modul gibt es eine abstrakte Klasse
  <code>ThermoBoxComponent</code> von welcher konkrete Komponenten erben können. Eine Komponente kann dann definieren
  welchen Kanälen Sie folgen möchte und welchen Handler sie anstössen möchte wenn eine Nachricht eintritt. Zudem gibt
  es eine Funktion um Nachrichten zu publishen.
</p>

<p>
  Die gewählte Architektur hat sich sehr bewährt. Es ermöglicht den selektiven Betrieb einzelner Komponenten so, dass
  diese isoliert getestet werden können. Zudem kann man auch mal eine Komponente ausschalten wenn man das Feature
  gerade nicht braucht. Zum Beispiel können wir den Uploader einfach nicht starten wenn wir nicht möchten, dass
  Dateien auf den Server hochgeladen werden. Es ist keine Konfigurationsänderung notwendig.
</p>

<p>
  Das einzige Problem das wir mit dieser Architektur festgestellt haben ist, dass wir Kameras haben auf welche mit
  nur einem Windows Prozess zugegriffen werden kann. Die erste Idee war, dass wir eine Komponente haben, welche die
  Farbkamera ausliest um zu erkennen ob gerade ein Zug in die Waschstrasse fährt. Eine zweite Komponente greift auf
  die selbe Kamera zu um die Bilder in ein Video aufzunehmen sobald der Zug erkannt wurde. Dies war leider nicht
  möglich. Also mussten wir in diesem konkreten und einzigen Fall vom Microservice-Pattern abweichen und beide
  Funktionalitäten in der selben Komponente implementieren.
</p>

<h4>Reader Komponenten</h4>
<p>
  Unter den Reader Komponenten verstehen sich Komponenten die eine Aufnahme tätigen oder eben einen Sensor auslesen.
  Die Reader Komponenten subscriben sich auf die Channels <code>capture:start</code>, <code>capture:stop</code> und
  <code>capture:abort</code>.</p>
<p>
  Beim Start Befehl wird ein Timestamp im Format <code>YYYY-MM-DD@HH-mm-ss</code>
  übergeben. Diesen Timestamp verwenden die Reader um einen eindeutigen Dateinamen zu erzeugen. Wenn diese Dateinamen
  später asynchron über diverse Wege wieder zusammengetragen werden können Sie wieder zusammen gruppiert werden und
  man weiss zu welcher Aufnahme sie gehören. Würden die Reader selber den Timestamp erzeugen ist durch die asynchrone
  Natur der Redis Message Queue nicht gegeben, dass die selben Timestamps zum Zuge kommen.
</p>

<p>
  Beim Stop Befehl stoppen die Reader ihre Aufnahme und schicken die erzeugte Datei an den jeweiligen Channel weiter.
</p>

<p>
  Beim Abbruch-Befehl werden die Reader die Aufnahme abbrechen und alle angefallenen Dateien aufräumen. Ein Abbruch
  kann unter anderem stattfinden wenn die Trigger Komponente sich dafür entscheidet die Aufnahme zu starten weil sie
  glaubt der Zug sei eingefahren. Später wird dann aber gemerkt, dass es ein Fehlalarm war und die Aufnahme
  abgebrochen werden sollte. Würde der Trigger warten bis er sich ganz sicher ist, könnte bereits ein Teil des Zuges
  durch gefahren sein ohne dass er aufgenommen wurde.
</p>

<p>
  Um manuelle Befehle zu geben haben wir ein Powershell Script <code>Control.ps1</code> erstellt mit welchem
  interaktiv die möglichen Befehle abgesendet werden können.
</p>

<h5>IRReader</h5>
TODO
<p>
  Die Aufgabe des IRReaders ist die Bilder FLIR Kamera aufzunehmen. Bevor die eigentliche Komponente gestartet wird,
  wird zuerst die Kamera gefunden.
</p>

<h5>VisibleLightReader</h5>
TODO
<p>
  Liest Bilder der Basler Kamera aus.
</p>

<h5>TemperatureReader</h5>
TODO
<p>

</p>

<h5>WeatherReader</h5>
<p>
  In der zweiten Aufnahmephase haben wir uns entschieden den TemperatureReader nicht mehr zu verwenden weil die
  Messdaten nicht brauchbar sind. Um die aufgenommenen IR Bilder trotzdem auswerten zu können haben wir den
  WeatherReader implementiert der aktuelle Wetterdaten von OpenWeatherMap herunterlädt.
</p>

<p>
  OpenWeatherMap bietet eine gratis API an um das aktuelle Wetter abzufragen. Um alte Daten abzufragen müsste man
  bezahlen. Deswegen haben wir uns entschieden die Daten jeweils dann abzufragen wann die Aufnahme gemacht wird.
  Durch das müssen wir nicht bezahlen. Die Daten können über einen HTTP GET Request abgefragt werden:
</p>

<figure>
  <pre><code>http://api.openweathermap.org/data/2.5/weather?q=Zürich,CH&appid={openWeatherMapApiKey}</code></pre>
  <figcaption>OpenWeatherMap API Request URL</figcaption>
</figure>

<p>
  Die Antwort die zurück kommt sieht dann ungefähr so aus:
</p>

<figure>
  <pre><code>{
  "coord": {"lon": 8.54, "lat": 47.37},
  "weather": [{
    "id": 802,
    "main": "Clouds",
    "description": "scattered clouds",
    "icon": "03n"
  }],
  "main": {
    "temp": 280.06,
    "pressure": 1016,
    "humidity": 71,
    "temp_min": 276.15,
    "temp_max": 284.15
  },
  "visibility": 10000,
  "wind": {"speed": 7.2, "deg": 240},
  "clouds": {"all": 40},
  "dt": 1514697600,
  "sys": {
    "sunrise": 1514704386,
    "sunset": 1514735106
  }
}</code></pre>
  <figcaption>OpenWeatherMap API Response</figcaption>
</figure>

<p>
  Der WeatherReader setzt eine Internetverbindung voraus. In der Zeit als das LTE Modul ausgefallen ist, hatten wir
  somit keine Wetterdaten sammeln können. Die Rate Limits der Gratis API Subsciprtion schränken uns mit 60 Calls pro
  Minute nicht ein. Etwas unschön ist, dass die Wetterdaten nur alle 2 Stunden aktualisiert werden wenn man nicht zahlt.
</p>

<h4>Delivery Komponenten</h4>

<h5>IRCompressor</h5>
TODO
<p>

</p>

<h5>Uploader</h5>
TODO
<p>

</p>

<h4>CLI Utils</h4>
TODO
<p>

</p>

<h5>SeqConverter</h5>
TODO
<p>
  Das SeqConverter CLI Programm dient zur Konvertierung von FLIR SEQ Dateien zu MP4 oder umgekehrt.
</p>

<h5>ExtractFrames</h5>
TODO
<p>
  Das ExtractFrames diente uns während der Nachbearbeitung und zur Erstellung von kurzen Testvideos anhand unseres
  Testmaterials. Dieses Tool kann schnell n Frames aus einem Video extrahieren und in einem Ordner ablegen.
</p>
